# Java-autoTest## 基于 Java 的接口自动化测试##[我的博客](https://blog.csdn.net/jianghao233/article/details/82423666)## 一、接口自动化测试## 1.接口定义接口：对外暴露的一个统一规范的接入点。<img src="http://pe9izua1e.bkt.clouddn.com/%E6%8E%A5%E5%8F%A3.png" width="850" hegiht="313" align=center />## 2.为什么要做接口测试1.更容易实现持续集成（背景就是第三点）     如何理解持续集成:     说背景---大型系统更多更复杂，系统间模块越来越多，组装的过程中出现的问题也越来越多,需要不断的迭代，不断的解决问题            2.自动化测试落地性性价比更高、比UI更稳定3.大型系统更多更复杂，系统间模块越来越多4.BUG 更容易定位，分模块进行测试5.降低开发成本、提高效率（bug 发现越早，修复成本越低）## 3.接口自动化测试开发技能树    1.开发语言：(如 Java）2.开发框架（如 TestNG、HttpClient） 3.Mock 技术（好处：1.在开发完成之前，要先模拟出接口调试测试代码  2.集成：前后端分离，将接口提供给前端开发人员使用，有测试产出）    4.数据持久层框架（如 MyBatis）    5.持续集成工具 （如 JenKins）    6.接口协议相关知识 （如 HTTP 协议）## 4.接口自动化测试落地过程产品开发阶段：<img src="http://pe9izua1e.bkt.clouddn.com/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B.png" width="850" hegiht="313" align=center />1.需求阶段（测试人员了解客户需求、解决用户痛点）   2.研发阶段 （测试人员的价值开始体现，如利用Mock 技术将接口提供给前端，提高整体的开发效率）3.测试阶段 （测试人员的主要负责阶段）4.项目上线## 二、接口测试的用例设计## 1.接口测试范围1.功能测试：验证产品逻辑是否正确<img src="http://pe9izua1e.bkt.clouddn.com/%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95.png" width="850" hegiht="313" align=center />2.异常测试<img src="http://pe9izua1e.bkt.clouddn.com/%E5%BC%82%E5%B8%B8%E6%B5%8B%E8%AF%95.png" width="850" hegiht="313" align=center />null : 是开发过程中特定指的一个对象为空的端符，就是一个空对象，不指向任何内存地址" " : 指一个空字符串，代表该对象有值，指向一个空地址负载均衡架构：测试某一个后台(Tomcat 4)挂了，挂了之后 Tomcat4的请求会直接返回一个错误（前台1个nginx ,后台多个 Tomcat），测试是否会返回这个错误，能否会使用户访问失败；一段时间后，想让 Tomcat4 重新加入，判断能否重新加入集群中并正确处理所有请求。冷热备份：冷备份不常见，热备份：前面有4个Tomca，后面有4个Tomca备份，如果Tomca4挂了，判断Tomca4的备份能否顶替之前的，仍然保持4个服务器存活；当Tomca4 正常后，判断能够成为Tomca4的备份。3.性能测试<img src="http://pe9izua1e.bkt.clouddn.com/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.png" width="850" hegiht="313" align=center />##2.自动化接口测试范围功能测试  +  数据异常测试环境异常测试示例：<img src="http://pe9izua1e.bkt.clouddn.com/%E7%8E%AF%E5%A2%83%E5%BC%82%E5%B8%B8.png" width="850" hegiht="313" align=center />## 三、手工接口测试到自动化框架设计## 手工接口测试的常用工具1.Postman2.HttpRequest3.Fiddler(具备抓包和发送请求功能)半自动化：Jmeter(结果统计方面不完善)###自动化框架的设计<img src="http://pe9izua1e.bkt.clouddn.com/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1.png" width="850" hegiht="313" align=center />## 四、测试框架TestNG## 1.TestNG 适合测试人员使用的原因：1.比 Junit 涵盖功能更全面的测试框架2.Junit 更适合隔离性比较强的单元测试3.TestNG 更适合复杂的集成测试（特别适合接口测试）	## 2.TestNG 的使用<img src="http://pe9izua1e.bkt.clouddn.com/TestNG%20%E4%BD%BF%E7%94%A8.png" width="550" hegiht="313" align=center />## 3.TestNG 基本注解与执行顺序实战### 1. 方法### @Test   : 最基本的注解，用来把方法标记为测试的一部分	### @BeforeMethod : 在测试方法之前运行的标签### @AfterMethod : 在测试方法之后运行的标签### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%89%8D%E4%B8%8E%E6%B5%8B%E8%AF%95%E4%B9%8B%E5%90%8E.png" width="550" hegiht="313" align=center />### 2. 类### 使用场景：在类正式运行之前，是否需要注册对象或一些静态的方法或变量赋值在该方法里写，写完之后其他的方法中可以使用；### @BeforeClass : 在类运行之前运行的方法### @AfterClass : 在类运行之后运行的方法### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E7%B1%BB%E4%B9%8B%E5%89%8D%E4%B8%8E%E7%B1%BB%E4%B9%8B%E5%90%8E.png" width="550" hegiht="313" align=center />### 3. 测试套件Suite 执行顺序在 类 的顺序之前 ，Suite 可以包含多个 class ,这个类属于某个测试套件之下，在运行之前可以包含多个 class， 执行顺序 是  Suite ---  class --- Method### @BeforeSuite : BeforeSuite测试套件### @AfterSuite : AfterSuite测试套件### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E6%B5%8B%E8%AF%95%E5%A5%97%E4%BB%B6%E5%89%8D%E5%90%8E.png" width="550" hegiht="313" align=center />### 4. 套件测试实例### 1.新建 LginTest.java :写测试主要的 Test 下包含的方法,登录测试--淘宝登录成功。### 2.新建 SuiteConfig.java :写测试套件之前运行的方法（共有的）### 3.新建 PayTest.java : 支付测试--支付宝支付成功### 3.新建 Suite.xml :放置测试套件的配置文件--Suite 取名 test（必须有 name 属性）,用 test 包裹不同的组件，每个 test 包含 SuiteConfig 与 Test。### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E5%A5%97%E4%BB%B6%E6%B5%8B%E8%AF%952.png" width="550" hegiht="313" align=center />### 输出顺序：测试套件包裹的在最外层，suite 先运行，输出 before suite；再运行测试标签 test ,即运行 beforeTest;接着运行第一个测试标签 test 里的 class（Login）,输出 淘宝登录成功；第一个测试标签 test 结束，即运行 aterTest,接着同理运行第二个测试标签 test 里的 class（pay）,输出 支付宝支付成功；test 结束，即运行 aterTest；整个测试套件结束,输出 after suite。### 5. 忽略测试### 定义：本次测试执行并不想执行这个测试，将其忽略即可### 新建 IgnoreTest.java ： 想忽略测试方法，在 @Test 方法后添加 (enabled = false) 即可；若添加 (enabled = true) 则也会执行，不会忽略。 ### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E5%BF%BD%E7%95%A5%E6%B5%8B%E8%AF%95.png" width="550" hegiht="313" align=center />### 6. 组测试中的方法分组测试### 定义：把很多测试方法归到一个组里面，再进行方法的渲染。### 新建 groups 包 ，创建 GroupsOnMethod.java :在 @Test 方法后添加 (groups = 名称) 即可,建立 4个 Test ,2个 groups 为 server，2个 groups 为 client；建立  @BeforeGroups("server")、@AfterGroups("server")、@BeforeGroups("client")、 @AfterGroups("client") 输出### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E5%88%86%E7%BB%84%E6%B5%8B%E8%AF%95.png" width="550" hegiht="313" align=center />### 7. 组测试中的类分组测试### 创建 GroupsOnClass1.java : 设置 @Test(groups = "stu")，建立 stu1 / stu2 对象，是 GroupsOnClass1### 创建 GroupsOnClass2.java :设置 @Test(groups = "stu")，建立 stu1 / stu2 对象，是 GroupsOnClass2### 创建 GroupsOnClass3.java :设置 @Test(groups = "teacher")，建立 teacher1() / teacher2() 对象，是 GroupsOnClass3### 创建 groupsOnClass.xml :  类测试的配置文件，设置2组test，会执行两次；### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E7%B1%BB%E6%B5%8B%E8%AF%951.png" width="550" hegiht="313" align=center />### groupsOnClass.xml : 设置 ` <run> <include name="stu"/> </run>` ，只执行 stu 对象；            ### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E7%B1%BB%E6%B5%8B%E8%AF%952.png" width="550" hegiht="313" align=center />### 8. 异常测试### 什么时候会用到异常测试？  (在我们期望结果为某一个异常的时候)比如：我们传入了某些不合法的参数，程序抛出了异常，也就是说我的预期结果就是这个异常。### 创建 ExpectedException.java :创建一个测试结果会失败的异常测试 runTimeExceptionFailed()，设置 @Test(expectedExceptions = RuntimeException.class)；### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E5%BC%82%E5%B8%B8%E6%B5%8B%E8%AF%951.png" width="550" hegiht="313" align=center />### 在ExpectedException.java :创建一个成功的异常测试 runTimeExceptionSuccess()，设置  @Test(expectedExceptions = RuntimeException.class)### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E5%BC%82%E5%B8%B8%E6%B5%8B%E8%AF%952.png" width="550" hegiht="313" align=center />### 9. 依赖测试### 定义：本个测试方法执行的时候依赖其他的方法。### 创建 DependTest.java :创建 test1() 和 test2()方法，test2()依赖于test1()，给test2设置 @Test(dependsOnMethods = {"test1"})；当test1()执行完成后再执行test2()；若test1()执行失败则test2()不再执行；### 当 test1 执行成功 ；输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E4%BE%9D%E8%B5%96%E6%B5%8B%E8%AF%951.png" width="550" hegiht="313" align=center />### 当 test2 执行失败 ；输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E4%BE%9D%E8%B5%96%E6%B5%8B%E8%AF%952.png" width="550" hegiht="313" align=center />### 10. 参数化测试### 定义：如何通外部或内部传递参数。### 创建包 com.course.testng.paramter ： 创建 ParamterTest.java ： @Parameters({"name","age"})  --传递参数（两个变量）### 创建配置文件 Paramter.xml ：放置配置文件，数据来源于该文件中类 ParamterTest### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95.png" width="550" hegiht="313" align=center />###将参数直接传到方法里### 在包 com.course.testng.paramter ： 创建 DataProviderTest.java ：创建 @Test(dataProvider = "data") 和 @DataProvider(name="data")，数据放在 providerData() 中；### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95-1.png" width="550" hegiht="313" align=center />### 通过方法名传递参数### 在 DataProviderTest.java ：创建 @Test(dataProvider = "methodData") 和 @DataProvider(name="methodData") ### 执行 test1：输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95-test1.png" width="550" hegiht="313" align=center />### 执行 test2：输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95-test2.png" width="550" hegiht="313" align=center />### 执行 test：输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95-testall.png" width="550" hegiht="313" align=center />### 11. 多线程测试### 通过注解实现多线程测试### 创建包 com.course.testng.multiThread ： 创建 MultiThreadOnAnnotion.java ： @Test(invocationCount = 10,threadPoolSize = 3)  --用10个线程来执行，设置现场池为3### 输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95.png" width="550" hegiht="313" align=center />### 通过配置文件xml实现多线程测试### 在包 com.course.testng.multiThread ： 创建 MultiThreadOnXml.java ： @Test(invocationCount = 10,threadPoolSize = ###创建配置文件 multiThread.xml ：放置配置文件，设置`<suite name="thread" parallel="methods" thread-count="3">` --设置多线程是方法级别，线程数是21.tests级别：不同的test tag下的用例可以在不同的线程下执行,相同的test tag下的用例只能在同一个线程中去执行2. classs级别：相同的class tag 下的用例在同一个线程中执行, 不同的class tag 下的用例可以在不同的线程中执行               3. methods级别：所有用例都可以在不同的线程下去执行4.thread-count：代表了最大并发线程数5.xml文件配置这种方式不能指定线程池，只有方法上才可以指定线程池### 12. 超时测试###定义：测试多长时间没有响应### 在包 com.course.testng ： 创建 TimeOutTest.java ：设置属性 @Test(timeOut = 3000)--单位为毫秒值 ，期待在3秒内得到响应结果### 测试成功输出效果：（超时3秒，线程睡眠2秒）<img src="http://pe9izua1e.bkt.clouddn.com/%E8%B6%85%E6%97%B6%E6%B5%8B%E8%AF%95--T.png" width="550" hegiht="313" align=center />### 测试失败输出效果：（超时2秒，线程睡眠3秒）<img src="http://pe9izua1e.bkt.clouddn.com/%E8%B6%85%E6%97%B6%E6%B5%8B%E8%AF%95--F.png" width="550" hegiht="313" align=center />## 五、测试报告## TestNG 测试报告展示<img src="http://pe9izua1e.bkt.clouddn.com/TestNG%20%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.png" width="550" hegiht="313" align=center />## ReportNg 测试报告<img src="http://pe9izua1e.bkt.clouddn.com/ReportNg%20%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.png" width="550" hegiht="313" align=center />## 一 、ExtentReport 介绍[ExtentReport 官网](http://extentreports.com/)## 1.新建 Maven project Chapter6 ## 配置 ExtentReport : 在 Pom.xml 中，通过  `<dependency>` 将 extentreports 导入## 新建 包 com.tester.extend.demo ，新建 TestMethodsDemo.java : 添加 TestNG 断言、日志及抛出异常`Reporter.log("这是我们自己写的日志");``throw new RuntimeException("这是我自己的运行时异常");`## 新建配置文件 testng.xml ：配置测试模块与监听器  ，测试报告加载失败（.css 加载不出来，因为被“墙"了）### 加载失败输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/ExtentReport%20%E9%85%8D%E7%BD%AE.png" width="550" hegiht="313" align=center />###  解决上述问题：新建 TestMethodsDemo.java : ExtentTestNGIReporterListenerOld.java ,放置从网上看到的解决方案代码；在 ExtentTestNGIReporterListener .java 中：怎么样解决cdn.rawgit.com访问不了的情况-- 添加代码`htmlReporter.config().setResourceCDN(ResourceCDN.EXTENTREPORTS);`### 解决样式加载不出的输出效果：<img src="http://pe9izua1e.bkt.clouddn.com/ExtentReport%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A.png" width="550" hegiht="313" align=center />